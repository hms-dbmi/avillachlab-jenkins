pipeline {
    agent any

    parameters {
        string(name: 'GROOVY_LIB_BRANCH', defaultValue: 'release-new-ui', description: 'The branch of the Groovy library to use')
        string(name: 'DISPLAY', defaultValue: '2', description: 'Weight for concept_node.DISPLAY')
        string(name: 'CONCEPT_PATH', defaultValue: '2', description: 'Weight for concept_node.CONCEPT_PATH')
        string(name: 'FULL_NAME', defaultValue: '1', description: 'Weight for dataset.FULL_NAME')
        string(name: 'DESCRIPTION', defaultValue: '1', description: 'Weight for dataset.DESCRIPTION')
        string(name: 'PARENT_DISPLAY', defaultValue: '1', description: 'Weight for parent.DISPLAY')
        string(name: 'GRANDPARENT_DISPLAY', defaultValue: '1', description: 'Weight for grandparent.DISPLAY')
        string(name: 'META_STRING', defaultValue: '1', description: 'Weight for concept_node_meta_str')
        string(name: 'GIT_REPO_URL', defaultValue: '${git_base_url}/picsure-dictionary.git', description: 'The GitHub repository URL')
        string(name: 'GIT_BRANCH', defaultValue: '', description: 'The Git branch to checkout')
        string(name: 'DOCKER_REPO', defaultValue: 'avillach', description: 'The Docker repository name')
        string(name: 'SPRING_PROFILE', defaultValue: 'bdc', description: 'The Spring profile')
        string(name: 'IMAGE_NAME', defaultValue: 'dictionary_weights', description: 'The name of the Docker image')
        string(name: 'DOCKER_IMAGE_VERSION', defaultValue: 'latest', description: 'The Docker image tag')
        string(name: 'DATASOURCE_URL', description: 'Datasource URL', defaultValue: '${database_psql_host_address}')
        string(name: 'DATASOURCE_USERNAME', description: 'Datasource username', defaultValue: '${database_psql_root_user_secret_name}')
    }

    environment {
        gitHash = ''
    }

    stages {
        stage('Build CSV') {
            steps {
                script {
                    def csvContent = """\
                    concept_node.DISPLAY,${params.DISPLAY}
                    concept_node.CONCEPT_PATH,${params.CONCEPT_PATH}
                    dataset.FULL_NAME,${params.FULL_NAME}
                    dataset.DESCRIPTION,${params.DESCRIPTION}
                    parent.DISPLAY,${params.PARENT_DISPLAY}
                    grandparent.DISPLAY,${params.GRANDPARENT_DISPLAY}
                    concept_node_meta_str,${params.META_STRING}
                    """

                    writeFile file: 'weights.csv', text: csvContent
                }
            }
        }

        stage('Archive CSV') {
            steps {
                archiveArtifacts artifacts: 'weights.csv', onlyIfSuccessful: true
            }
        }

        stage('Retrieve Build Spec') {
            steps {
                script {
                    // Trigger the 'Retrieve Build Spec' job and get the build number
                    def projectName = 'Retrieve Build Spec'

                    def result = build job: projectName
                    def retrieveBuildSpecId = result.number

                    // Copy the artifacts from the triggered job
                    copyArtifacts filter: '*', projectName: projectName, selector: specific("${retrieveBuildSpecId}")

                    // Display the content of the files for debugging
                    sh 'cat build-spec.json'


                }
            }
        }

        stage('Clone Repository') {
            steps {
                script {
                    // Define the path for the build spec file and project name
                    def buildSpecFile = 'build-spec.json'
                    def projectName = 'PIC-SURE Dictionary Build'

                    // Extract the git_hash using jq and store it in a global variable
                    gitHash = sh(
                        script: "jq -r '.application[] | select(.project_name == \"${projectName}\") | .git_hash' ${buildSpecFile}",
                        returnStdout: true
                    ).trim()

                    def ref = (params.GIT_BRANCH?.trim()) ? params.GIT_BRANCH : gitHash
                    println "Ref: ${ref}"
                    println "Git Hash: ${gitHash}"

                    checkout([$class: 'GitSCM',
                        branches: [[name: ref]],
                        userRemoteConfigs: [[url: "${params.GIT_REPO_URL}"]],
                        extensions: [
                            [$class: 'SparseCheckoutPaths', sparseCheckoutPaths: [
                                [path: 'dictionaryweights']
                            ]],
                            [$class: 'CheckoutOption', timeout: 10],
                            [$class: 'CloneOption', depth: 1, noTags: false, shallow: true]
                        ]
                    ])
                }
            }
        }

        stage('Build Dictionary Docker Image') {
            steps {
                dir('dictionaryweights') {
                    script {
                        def buildArgs = " --build-arg DATASOURCE_URL=${params.DATASOURCE_URL} " +
                                        " --build-arg DATASOURCE_USERNAME=${params.DATASOURCE_USERNAME} " +
                                        " --build-arg SPRING_PROFILE=${params.SPRING_PROFILE}"

                        sh "docker build --no-cache ${buildArgs} -t '${params.DOCKER_REPO}/${params.IMAGE_NAME}:${params.DOCKER_IMAGE_VERSION}' ."
                    }
                }
            }
        }


       stage('Run Docker Container') {
           steps {
               script {
                   // Set the role ARN and session name
                   def roleArn = "arn:aws:iam::${env.app_acct_id}:role/${env.jenkins_provisioning_assume_role_name}"
                   def sessionName = "jenkins-session-${env.BUILD_ID}"

                   // Assume the role using AWS CLI
                   def assumeRoleResponse = sh(script: """
                       aws sts assume-role \
                         --role-arn "${roleArn}" \
                         --role-session-name "${sessionName}" \
                         --output json
                   """, returnStdout: true).trim()

            // Parse the JSON response to extract credentials using jq
            def accessKeyId = sh(
                script: "echo '${assumeRoleResponse}' | jq -r '.Credentials.AccessKeyId'",
                returnStdout: true
            ).trim()

            def secretAccessKey = sh(
                script: "echo '${assumeRoleResponse}' | jq -r '.Credentials.SecretAccessKey'",
                returnStdout: true
            ).trim()

            def sessionToken = sh(
                script: "echo '${assumeRoleResponse}' | jq -r '.Credentials.SessionToken'",
                returnStdout: true
            ).trim()

                   echo "Running Docker container..."

                   // Use the Docker run command correctly
                   sh """
                       docker run \
                         --rm \
                         -t \
                         --name dictionary-weights \
                         -v ./weights.csv:/weights.csv \
                         -e AWS_ACCESS_KEY_ID=${accessKeyId} \
                         -e AWS_SECRET_ACCESS_KEY=${secretAccessKey} \
                         -e AWS_SESSION_TOKEN=${sessionToken} \
                         -e AWS_DEFAULT_REGION=us-east-1 \
                         ${params.DOCKER_REPO}/${params.IMAGE_NAME}:${params.DOCKER_IMAGE_VERSION}
                   """
               }
           }
       }

    }
}
